# C++ Primer
- [C++ Primer](#c-primer)
  - [变量](#变量)
    - [基本类型](#基本类型)
    - [复合类型](#复合类型)
    - [const限定符](#const限定符)
    - [auto&decltype](#autodecltype)
    - [Tips](#tips)
  - [表达式](#表达式)
  - [函数](#函数)
  - [类](#类)
  - [STL](#stl)
    - [顺序容器](#顺序容器)
    - [关联容器](#关联容器)
  - [模板与泛型](#模板与泛型)
  - [内存管理](#内存管理)
  - [其他](#其他)

## 变量
### 基本类型
1. 算术类型和空类型
    
    算数类型

    |   类型    |    大小    |         精度          |
    | :-------: | :--------: | :-------------------: |
    | bool      | 未定义      | true / false          |
    |    int    |   4bytes   |                       |
    |   short   | 不大于int  |                       |
    |   long    | 不小于int  |                       |
    | long long | 通常8bytes |                       |
    |   float   |   4bytes   |  至少6，通常7位小数   |
    |  double   |   8bytes   | 至少10， 通常16位小数 |
    |   char    |   1byte    |                       |
    |wchar_t| 64位ubuntu上4byte| 宽字符, 根据机器和系统, <br>用于确保可以存放机器最大扩<br>展字符集中的任意字符|
    空类型: void
    
    **Tips:**
   - signed&unsigned
       两者在bit级别没有差异,差异在于读取时的理解
       重点注意unsigned和signed混用进行运算时, signed会首先隐式转换为unsigned在进行运算,这种情况应当避免.
   - 在算术表达式中避免使用char类型,不同机器的实现可能是signed也可能是unsigned, 如果一定要使用一个不大的整数, 可以使用signed char.
   - 内置类型的变量, 作为全局变量时默认初始化为0, 作为局部变量时, 未定义
   - 所有变量可以用extern声明, 声明后变量名可用,并且类型按照声明的类型. 定义时才真正分配空间, 在单文件的情况下不存在只声明的情况, 在单文件程序中, 用`extern int i = 5;`其实是定义了i, 并且不能用在函数内部


2. 类型转换

    - signed和unsigned的转换: 底层bit不变, 解释发生变化
    - 整型到浮点数的转换: 不发生改变, 如果整数所占空间超过了浮点数容量, 精度损失
    - 浮点数到整型的转换: 结果值保留小数点前, 做近似处理,向0取整 (等价于直接截断)
    - 短长度类型到长长度类型的转换: 不发生改变
    - 长长度类型到短长度类型的转化: 如果是赋给无符号类型, 结果是初始值对无符号类型表示数值总数取模后的余数. 例如unsigned char的范围0-255, 将-1赋给它, 得到255; 赋给带符号类型时, 结果是未定义的
    - 当一个算术表达式中既有无符号数又有有符号数时, 有符号值会转换成无符号值

3. 定义与声明

    函数的声明: 函数的声明即是原型, 形参可以不给标识符但是必须给出类型
    函数的定义: 函数的定义带有具体的函数体

    **Tips**: 
    - 函数的声明后面需要接分号, 函数的定义后面不能接

    变量的声明: 变量的声明使用extern关键字
    变量的定义: 变量的定义只能够在所有文件中出现一次, 变量在定义时分配空间, 能够跨文件出现的变量通常位于内存的数据区, 可能是.data 段也可能是.bss段(为定义初始值的全局变量的位置)

4. 作用域

5. 初始化
### 复合类型
### const限定符

const变量默认的作用范围是文件内, 编译阶段编译器拿着值替换文件内的该变量. 不同文件的同名const变量相互独立, 如果需要在不同文件中共享同一个const变量, 需要在定义和声明时都加上extern.

顶层const&底层const

- 顶层const指的是指针本身是const, 底层const表示指针所指的对象是一个常量.
- 顶层const的写法在右边 `int *const pi = &i`. 底层const的写法在左边, `const int * pi = ci;`

**常量表达式**指的是, 值不会改变并且在编译过程就能得到计算结果的表达式.

**constexpr**: 在一个复杂系统中, 很难分辨一个初始值到底是不是常量表达式, c++11允许将变量声明为constexpr类型, 由编译器来验证变量的值是否是一个常量表达式. 声明为constexpr的变量一定是个一个常量, 而且必须用**常量表达式**初始化.

算术类型, 引用和指针都属于字面量类型, 自定义类, IO库, string类型都不属于字面量类型, 都不能被定义为constexpr.

尽管指针和引用类型可以被定义为constexpr, 但是它们的右值非常严格, 只能是0, nullptr或存储在某个固定地址中的对象.

constexpr修饰的指针, 限定符对指针有效, 即constexpr修饰的一定是一个顶层const. 以下定义的是一个指向整数的常量指针.`constexpr int *q = nullptr`, 相对应的, 这样的const定义的是一个指向整型常量的指针`const int *p = nullptr`.

### auto&decltype

### Tips

- 标识符, 不允许以两个连续的下划线, 不允许"_ + 大写字母", 不允许函数以下划线开头
- **引用和指针的区别**: 都占用了一个地址的空间内存, 在汇编层面相同, 但引用不是对象, 指针是
- 尽量使用nullptr代替NULL, 尽管目前没有区别
- void* 类的指针可以赋值, 比较, 但不能使用其指向的对象, 因为无法预知内存长度
- 对于 `int* p, q;` * 只修饰了p, 而非整行. 因此 *p, *q的紧邻写法更好
- 面对指针或引用的复杂声明时, 采用从右向左读的方式理解, `int *&r = b`的含义, `&r`--引用, `*`--指针引用, `int *`整型指针

## 表达式

- 当一个对象被用作右值时, 用的是它的内容, 当一个变量作为左值时, 用的是它的身份(内存位置)
- 一个左值可以被当做右值使用, 一个右值不能被当做左值使用
- 对于没有制定运算顺序的运算, 如果表达式指向并修改了同一个对象, 其结果是未定义的
- 对于一个表达式中的不同函数的运算顺序, 很多时候是不确定的
- 比较运算符的优先级高于相等运算符
- 赋值优先级低于关系运算符
- 后置递增的性能不如前置递增
- 条件运算符的表达式要求类型一致或至少可以转换为同一类型
- sizeof 有两种用法, sizeof(type)和sizeof expr, 前者可以用于类, 后者用于对象(实例)
- 当sizeof作用于解引用的指针时, 即使指针为空也是安全的, 不会真访问值
- sizeof 作用域数组名 不会自动转换为指针
- 如果运算对象一个是无符号类型一个是有符号类型, 并且无符号类型不小于有符号类型的话, 有符号类型转换为无符号类型.
- 使用新式的强制转换 cast_name\<type\> (expr), static_cast, const_cast, reinterpret_cast

## 函数
- 可以设置未命名的形参, 调用时需要给初始值, 但不会被函数用到
- 形参仅从T类变为const T类, 不是合法的重载, 原因是初始化时, 顶层const被忽略
- 对于只读不修改的形参, 应定义为常量引用, 否则会限制实参类型, 使const对象, 字面量和需要进行类型转换的对象不能传入.
- 返回数组的指针或引用的函数声明的四种写法
- 不同作用域声明的同名函数不会被重载, 外层函数直接被隐藏.
- 默认实参可以是函数返回值或变量, 并且对变量的修改会被更新, 因为默认实参的求值发生在调用时.
- 规模小, 流程直接, 调用频繁的函数, 可以声明成内联, 递归和大于75行的函数不可以声明为内联, 声明为内联只是请求, 不是保证.
- NDEBUG预处理变量和四个调试用变量和assert可以一起使用.
## 类
- 使用struct和class定义类的唯一区别就是默认的访问权限.
- 定义在类内部的函数, 是隐式的inline函数
- 常量成员函数是在形参列表之后加一个const, 含义是函数所用的this指针指向的const的本类对象.
- 常量对象的指针和引用, 只能调用常量函数
- 编译器对类的处理分两步, 首先编译成员的声明, 再编译成员函数的, 因此成员变量可以先使用后定义.
  
## STL

### 顺序容器
- vector 可变大小的数组，随机访问，尾部以外的位置插入删除元素很慢
- list 双向链表，双向顺序访问，头尾插入删除速度快
- deque 双端队列，随机访问，头尾插入/删除速度快
- forward_list 单向列表，单向顺序访问，任何位置插入/删除速度快
- array 固定大小的数组，不能添加删除元素
- string 与vector相似，尾部插入/删除速度快

Tips:
- 如果在读取输入时，需要向中间插入元素，之后需要随机访问，可以在输入阶段使用list，之后拷贝到vector当中进行查找
- 顺序容器的一个版本的构造函数接受容器的大小参数，它使用了元素类型的默认构造函数，但某些类没有默认构造函数，这时，我们可以定义保存这种类型的对象的容器，但是不能在构造这种容器时只传递给它一个元素的数目参数。


**顺序容器的操作**


- 迭代定义了递增减，但forward-list的没有定义--
- 向vector，deque，string插入元素会使所指向的容器的引用，指针，迭代器失效
- 删除deque首尾以外的元素会使指向其的所有指针，引用，迭代器失效，删除vector的stag元素，会使删除点之后的的所有引用，指针，迭代器失效

**vector对象的增长**


**容器适配器**

### 关联容器
关联容器主要包括map, set, multimap, multiset以及上述四种容器的unodered版本, 搭配使用的还有pair以及make_pair函数.

关联容器的数据类型别名
key_type: 键对应的数据类型, 对于set就是元素自身
maped_type: 值类型, 对于set就是元素自身
value_type: set就是其自身元素的类型;map是`pair<key_type, map_type>`类型

关联容器的插入操作

关联容器的删除操作

关联容器的更改操作

关联容器的查询

## 模板与泛型

## 内存管理

## 其他
