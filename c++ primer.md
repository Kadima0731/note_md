# C++ Primer
- [变量](#变量)
  - [基本类型](#基本类型)
  - [复合类型](#复合类型)
  - [const限定符](#const限定符)
  - [auto&decltype](#autodecltype)
  - [Tips](#tips)
- [函数](#函数)
- [类](#类)
- [STL](#stl)
  - [关联容器](#关联容器)
- [模板与泛型](#模板与泛型)
- [内存管理](#内存管理)
- [其他](#其他)

## 变量
### 基本类型
1. 算术类型和空类型
    
    算数类型

    |   类型    |    大小    |         精度          |
    | :-------: | :--------: | :-------------------: |
    | bool      | 未定义      | true / false          |
    |    int    |   4bytes   |                       |
    |   short   | 不大于int  |                       |
    |   long    | 不小于int  |                       |
    | long long | 通常8bytes |                       |
    |   float   |   4bytes   |  至少6，通常7位小数   |
    |  double   |   8bytes   | 至少10， 通常16位小数 |
    |   char    |   1byte    |                       |
    |wchar_t| 64位ubuntu上4byte| 宽字符, 根据机器和系统, <br>用于确保可以存放机器最大扩<br>展字符集中的任意字符|
    空类型: void
    
    **Tips:**
   - signed&unsigned
       两者在bit级别没有差异,差异在于读取时的理解
       重点注意unsigned和signed混用进行运算时, signed会首先隐式转换为unsigned在进行运算,这种情况应当避免.
   - 在算术表达式中避免使用char类型,不同机器的实现可能是signed也可能是unsigned, 如果一定要使用一个不大的整数, 可以使用signed char.
   - 内置类型的变量, 作为全局变量时默认初始化为0, 作为局部变量时, 未定义
   - 所有变量可以用extern声明, 声明后变量名可用,并且类型按照声明的类型. 定义时才真正分配空间, 在单文件的情况下不存在只声明的情况, 在单文件程序中, 用`extern int i = 5;`其实是定义了i, 并且不能用在函数内部


2. 类型转换

    - signed和unsigned的转换: 底层bit不变, 解释发生变化
    - 整型到浮点数的转换: 不发生改变, 如果整数所占空间超过了浮点数容量, 精度损失
    - 浮点数到整型的转换: 结果值保留小数点前, 做近似处理,向0取整 (等价于直接截断)
    - 短长度类型到长长度类型的转换: 不发生改变
    - 长长度类型到短长度类型的转化: 如果是赋给无符号类型, 结果是初始值对无符号类型表示数值总数取模后的余数. 例如unsigned char的范围0-255, 将-1赋给它, 得到255; 赋给带符号类型时, 结果是未定义的
    - 当一个算术表达式中既有无符号数又有有符号数时, 有符号值会转换成无符号值

3. 定义与声明

    函数的声明: 函数的声明即是原型, 形参可以不给标识符但是必须给出类型
    函数的定义: 函数的定义带有具体的函数体

    **Tips**: 
    - 函数的声明后面需要接分号, 函数的定义后面不能接

    变量的声明: 变量的声明使用extern关键字
    变量的定义: 变量的定义只能够在所有文件中出现一次, 变量在定义时分配空间, 能够跨文件出现的变量通常位于内存的数据区, 可能是.data 段也可能是.bss段(为定义初始值的全局变量的位置)

4. 作用域

5. 初始化
### 复合类型
### const限定符
### auto&decltype

### Tips

- 标识符, 不允许以两个连续的下划线, 不允许"_ + 大写字母", 不允许函数以下划线开头
- **引用和指针的区别**: 都占用了一个地址的空间内存, 在汇编层面相同, 但引用不是对象, 指针是
- 尽量使用nullptr代替NULL, 尽管目前没有区别
- void* 类的指针可以赋值, 比较, 但不能使用其指向的对象, 因为无法预知内存长度
- 对于 `int* p, q;` * 只修饰了p, 而非整行. 因此 *p, *q的紧邻写法更好
- 面对指针或引用的复杂声明时, 采用从右向左读的方式理解, `int *&r = b`的含义, `&r`--引用, `*`--指针引用, `int *`整型指针
## 函数

## 类

## STL

### 关联容器
关联容器主要包括map, set, multimap, multiset以及上述四种容器的unodered版本, 搭配使用的还有pair以及make_pair函数.

关联容器的数据类型别名
key_type: 键对应的数据类型, 对于set就是元素自身
maped_type: 值类型, 对于set就是元素自身
value_type: set就是其自身元素的类型;map是`pair<key_type, map_type>`类型

关联容器的插入操作

关联容器的删除操作

关联容器的更改操作

关联容器的查询

## 模板与泛型

## 内存管理

## 其他
